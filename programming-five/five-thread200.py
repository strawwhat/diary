#!/usr/bin/python
# *-*coding:utf-8 *-*

"""
同步访问共享对象和名称
线程的好处之一是它们自动带有任务间通信机制：
在线程的生命期间一直持续寸在的进程中，对象的和
命名空间的在所有派生线程间共享

---------------------------------------------------
_thread.allocate_lock() 返回一个新的锁对象.

lock.acquire(waitflag=1, timeout=-1) 获得锁
如果没有任何可选参数，此方法将无条件得获取锁，
如果需要，请等待它由另一个线程释放(每次只有一个线程可以获取锁，这就是存在的原因)
如果waitflag参数存在，则操作取决于其值：如果为零，则只有在不等待的情况下才能立即获取锁
而如果它是非零，则将无条件的获取锁

如果浮点超时参数存在且为正值，则它指定返回最大等待时间(以秒为单位),
负的超时参数指定无界等待，如果waitflag为零，则不指定超时
如果成功获取锁，则返回值为True否则为False
----------------------
lock.release()
释放锁。锁必须提前获得，但不一定是同一个线程
----------------
lock.locked()
返回锁状态：如果已经被某个线程获取，则为True，否则为False
------------------------------
示例5-7 thread-count-mutex.py page200 实现打印的同步化

避免数个线程同时改变全局对象和名称。
为了使代码更健壮，带有线程的程序必须控制对全局对象的访问权，
保证同一时间内只能有一个线程在使用它们。
python的_thread模块自带了方便的工具
这些工具基于锁的概念：要想修改一个共享对象，线程需要获得一把锁，
然后进行修改，之后进行释放，后者再为其他线程获取。
python确保任何时间点只有一个线程持有锁，如果在持有期间其他线程请求获得锁，
那么这些请求将一直被阻塞，直到释放出锁。
锁对象的分配和处理由简单且可跨平台移植的_thread模块中调用执行，
后者自动映射到底层操作平台的线程锁定机制
"""

import _thread, time

def counter(myId, count):
	for i in range(count):
		time.sleep(1)
		mutex.acquire()
		print("[%s] => %s" % (myId, i))
		mutex.release()

mutex = _thread.allocate_lock() #创建全局锁对象

for i in range(5):
	_thread.start_new_thread(counter, (i, 5))

time.sleep(6) #把sleep放到循环内，myID值会有序输出。但线程输出不再是同步打印
print("Main thread end!")














