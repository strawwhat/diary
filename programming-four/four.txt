#!/usr/bin/env python
# *-*coding:utf-8 *-*

"""经验性原则，一般可以把使用python程序进行的各种处理转交给内建工具来完成，从而使程序提速 """

& 按位与运算  两个相应位都为1时结果为1
| 按位或 两个相应位有一个为1 结果位就为1
^ 按位异或 两个相应位相异时结果为1
~ 按位取反 对数据的每个二进制位取反，即把1变成0, 0变成1

file.seek() seek方法用于移动文件读取指针到指定位置
file.flush() 是用来刷新缓冲区的，即将缓冲区的数据立刻写入文件，同时清空缓冲区，
不需要是被动的等待输出缓冲区写入。 一般情况下文件关闭后会自动刷新缓冲区，但有时
你需要在关闭前刷新它，这时就可以使用flush()方法
python 定义了6种基本类型 字符串 整数 浮点数 列表 元组 字典

struct模块
将某些特定的结构类型打包成二进制流的字符串然后再网络传输，而接收端也应该可以通过
某种机制进行解包还原出原始的结构体数据

os通过调用文件描述符来处理文件，描述符是整数代码或者“句柄”，代表着操作系统中的文件
基于描述符的文件以原始字节形式进行处理，而且没有我们之前所学的文本的换行符和Unicode
转换概念。
事实上处理缓冲的额外性能，基于描述符的文件一般都能对应上二进制模式文件对象
尽管内建文件对象和os模块的描述符文件由不同的工具负责处理，但它们其时是相互关联的
文件对象所使用的文件系统就是仅仅在基于描述符的文件工具之上添加了一层逻辑所得

fileno() 文件对象方法返回一个整型的文件描述符，可用于底层操作系统的I/O操作
fileno文件对象方法返回的整数描述符是与某个内建文件对象相关联的
调用os.wrtie函数，通过描述符将数据发送至stdout，与调用sys.stdout.wrtie方法是一样的


---os.open()的模式标识符---
fdfile = os.open(r'data.txt', os.O_RDWR)
os模块为什么会提供额外的文件工具呢？简而言之，它们为文件处理提供更多底层控制
os.open()的标识符可以让我们在打开文件时指定更高的参数，比如唯一访问权（O_EXCL）

带有O_EXCL标识符的os.open()现在是python中在并发或其他进程同步情况下锁定文件的最便捷方法
在一台服务器上并行运行着多个程序，如果多个线程或进程试图同时更新，
那么在执行更新前可能需要将文件锁定


---把描述符封装进文件对象---
利用os.fdopen()调用把文件描述符封装进文件对象
objfile = os.fdopen(fdfile, 'rb')

在Python3.X中，内建open调用也接受文件描述符代替文件名字字符串的做法
这个模式下，它的运作方式类似os.fdopen，但可以提供更多的控制权

------------------------------------------------------------------------------------------------

#!/usr/bin/python
# *-*coding:utf-8 *-*

"""
目录工具

遍历目录
os.popen() 运行shell命令字符串，并返回一个文件对象，
可以从这个文件对象中读取命令的输出

返回换行符号，并可能在某些平台上对名称进行排序
os.popen(r'ls filepath').readlines()
os.popen('dir filepath').readlines()

glob.glob() 接收一个模式作为参数并返回带目录前缀的文件名
'?'代表任意单个字符， '*'代表任意个的字符， '[]'字符集
glob.glob(r'filepath ?*[].py')

os.listdir() 需要一个简单的目录名，并返回不带目录前缀的名称
os.listdir('filepath')

python3.x中os.listdir()以两种模式运行：
如果给定的是bytes参数，那么函数将以编码好的字节字符串形式返回文件名
如果是普通的str字符串参数,那么它返回的文件名是Unicode字符串，而这个
字符串已经根据文件系统的编码体系做过解码了。

因为os.walk和glob.glob都通过内部调用os.listdir()而运行，所以它们也间接地继承了这些性能
"""




